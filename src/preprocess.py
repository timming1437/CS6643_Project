# -*- coding: utf-8 -*-
"""preprocess.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mSzM1YZAwq3wjiIYDqlR0lEDsFSLgHHg
"""


# Commented out IPython magic to ensure Python compatibility.
# %pip install chess

# Commented out IPython magic to ensure Python compatibility.
# %pip install svglib

from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import Activation, Dropout, Flatten, Dense
from keras.models import Model
from keras.applications.vgg16 import VGG16
from keras.applications.imagenet_utils import decode_predictions
  
import cv2
import numpy as np
import scipy.spatial as spatial
import scipy.cluster as cluster
import math
from collections import defaultdict

import glob
import PIL
from PIL import Image
import chess
import chess.svg
from svglib.svglib import svg2rlg
from reportlab.graphics import renderPM
import re

def model(pretrained_model, parameter_file):
  for layer in pretrained_model.layers:
    layer.trainable = False
  input = pretrained_model.output
  flatten = Flatten()(input)
  fc1 = Dense(500, activation = "relu")(flatten)
  fc2 = Dense(500, activation = "relu")(fc1)
  output = Dense(13, activation = "softmax")(fc2)
  modified_model = Model(inputs = pretrained_model.input, outputs = output)
  modified_model.compile(optimizer = 'adam', loss = 'categorical_crossentropy', metrics = ['categorical_accuracy'])
  modified_model.load_weights(parameter_file)
  return modified_model

def group_points(intersections):
  #computer pairwise dist
  distance = spatial.distance.pdist(intersections)
  # computer single linkage which will be used in clustering
  single_lin = cluster.hierarchy.single(distance)
  # get group the points by clustering
  f_clusters = cluster.hierarchy.fcluster(single_lin, 15, 'distance')
  num_clusters = len(f_clusters)
  temp_clusters = defaultdict(list)
  for i in range(num_clusters):
    temp_clusters[f_clusters[i]].append(intersections[i])
  values = temp_clusters.values()
  values = np.array(values)
  clusters = map(lambda n: (np.mean(n[: , 0]), np.mean(n[: , 1])), values)
  # sort the clusters
  sorted_points = sorted(list(clusters), key = lambda n: [n[1], n[0]])

  return sorted_points

# attached the averaged y value for each row to get the final cooridinates of the points
def final_points(sorted_points):
  result = []
  num_rows = int(np.shape(sorted_points)[0] / 11)
  for row in range(num_rows):
    start = row * 11
    end  = row * 11 + 10
    points = sorted_points[start : end + 1]
    y = []
    x = []
    for p in points:
      x.append(p[0])
      y.append(p[1])
      y_avg = np.mean(np.array(y))
    for i in range(len(x)):
      final_p = (x[i], y_avg)
      result.append(final_p)
  ## sort the final points
  result = sorted(result, key = lambda n: [n[1], n[0]])

  return result

## divide the image of the board into small patches for chess piece classification
## no return value
def divide_the_board(img, points, output_folder): 
  dim = np.shape(points)[0]
  start_point = dim - 14
  range_num = 8
  if int(dim / 11) < 8:
    range_num = int(dim / 11 - 2)
  
  nums = []
  count = 0
  for row in range(range_num):
    start = start_point - (row * 11)
    end = start_point - 8 - (row * 11)
    nums.append(range(start, end, -1))
  
  for row in nums:
    for i in row:
      bottom_left = points[i]
      bottom_right = points[i + 1]
      length = math.dist(bottom_left, bottom_right)

      x_start = int(bottom_left[0])
      y_start = int(bottom_left[1] - (length * 2))
      if y_start <0:
        y_start = 0

      x_end = int(bottom_right[0])
      y_end = int(bottom_right[1])

      patch = img[y_start: y_end, x_start, x_end]
      count += 1

      cv2.imwrite(output_folder + "img" + str(count) + ".jpg", patch)

    print("board image processed.")

## prepare the image for the DL model
def prepare_img(img_file, img_size = (224,224)):
  ## reads in image and transform it from RGB to BGR
  img = PIL.Image.open(img_file).resize(img_size)
  img_data = img.getdata()
  img_data = np.array(img_data, np.float32).reshape(*img_size, -1)
  img_data = np.flip(img_data, axis = 2)

  ## transform the image as the tensor input form for the model
  img_data[:, :, 0] -= 103.923
  img_data[:, :, 1] -= 116.779
  img_data[:, :, 2] -= 123.68

  tensor = np.expand_dims(img_data, axis = 0)

  return tensor

def atoi(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    return [atoi(c) for c in re.split('(\d+)', text)]

def classification(model, img_folder):
  ## get the paths to images of the chess pieces
  img_files = []
  for f in glob.glob(img_folder):
    img_files.append(f)
  img_files.sort(key = natural_keys)
  
  labels = ['b', 'k', 'n', 'p', 'q', 'r', '1', 'B', 'K', 'N', 'P', 'Q', 'R']
  results = []
  for f in img_files:
    img = prepare_img(f)
    output = model.predict(img)
    label = labels[np.argmax(output)]
    results.append(label)

  return results

## transform the classification results to Forsyth-Edwards Notation
def result_to_fen(labels):
  fen_notation = ''.join(labels)
  fen_notation = '/'.join(fen_notation[i:i + 8] for i in range(0, len(fen_notation), 8))
  digit_sum = 0
  for i, p in enumerate(fen_notation):
      if p.isdigit():
          digit_sum += 1
      elif p.isdigit() is False and (fen_notation[i - 1].isdigit() or i == len(fen_notation)):
          fen_notation = fen_notation[:(i - digit_sum)] + str(digit_sum) + ('D' * (digit_sum - 1)) + fen_notation[i:]
          digit_sum = 0
  if digit_sum > 1:
      fen_notation = fen_notation[:(len(fen_notation) - digit_sum)] + str(digit_sum) + ('D' * (digit_sum - 1))
  fen_notation = fen_notation.replace('D', '')
  return fen_notation

def draw_board(fen_notation, file_name, output_folder):
  temp_board = chess.Board(fen_notation)
  board = chess.svg.board(board = temp_board)
  output = open(output_folder + file_name + '.svg', 'w')
  output.write(board)
  output.close()

  output_svg = svg2rlg(output_folder + file_name)
  renderPM.drawToFile(output_svg, output_folder + file_name + '.png', fmt = 'PNG')

  print("board file created.")
